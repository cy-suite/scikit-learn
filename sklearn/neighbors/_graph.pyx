# Author: Jee Won (Kyra) Park, partly generated by gemini & copilot.
cimport cython
from libc.math cimport sqrt

'''
This function takes two 1D numpy arrays as input, representing 
the coordinates of two points. It computes the square of the 
distance between these points in a loop, which is faster 
than using numpy's built-in functions due to the overhead
of function calls in Python. The square root of the total 
square distance is then returned as the Euclidean distance.

The decorators @cython.boundscheck(False) and @cython.wraparound(False)
are used to disable bounds checking and negative indexing, 
respectively, which can speed up the code when you're sure 
that your indices are always valid.  TODO: this should probably
be changed to use check_array(). The nogil keyword is used 
to allow this function to be called in a multi-threaded context.
'''

@cython.boundscheck(False)  # Deactivate bounds checking
@cython.wraparound(False)   # Deactivate negative indexing.
cdef double compute_distance(double[:] point1, double[:] point2) nogil:
    cdef:
        int dim = point1.shape[0]
        int i
        double sqdist = 0.0

    for i in range(dim):
        sqdist += (point1[i] - point2[i]) ** 2

    return sqrt(sqdist)






import numpy as np
cimport cython

cdef extern from "math":
    double sqrt(double x)

@cython.boundscheck(False)
@cython.wraparound(False)
@cython.initialized

def cdist(double[:, ::1] X, double[:, ::1] Y):
  """
  Cython optimized distance calculation between two sets of points.

  Args:
      X: A 2D numpy array of shape (n_samples1, n_features) representing the first set of points.
      Y: A 2D numpy array of shape (n_samples2, n_features) representing the second set of points.

  Returns:
      A 2D numpy array of shape (n_samples1, n_samples2) containing the pairwise distances between points in X and Y.
  """
  cdef int n_samples1, n_samples2, n_features
  cdef double[:] distances
  cdef int i, j, f

  n_samples1 = X.shape[0]
  n_samples2 = Y.shape[0]
  n_features = X.shape[1]

  distances = np.zeros(shape=(n_samples1, n_samples2), dtype=np.float64)

  # Loop through each point in X
  for i in range(n_samples1):
    # Loop through each point in Y
    for j in range(n_samples2):
      # Calculate squared distance for efficiency
      for f in range(n_features):
        distances[i, j] += (X[i, f] - Y[j, f]) ** 2

      # Take the square root only if necessary (e.g., Euclidean distance)
      distances[i, j] = sqrt(distances[i, j])

  return distances

def radius_neighbors_graph_cython(X, radius, *, mode="connectivity",
                                  metric="minkowski", p=2,
                                  metric_params=None, include_self=False,
                                  n_jobs=None):
  """
  Compute the (weighted) graph of Neighbors for points in X using Cython optimized distance calculation.

  This function replicates the functionality of scikit-learn's radius_neighbors_graph
  but uses Cython for faster distance computations.

  Refer to the original radius_neighbors_graph documentation for details on parameters.

  Returns:
      A sparse matrix of shape (n_samples, n_samples)
  """
  # Delegate remaining logic (neighbor search, graph construction) to original implementation
  # but replace the distance calculation with the optimized Cython function
  knn = NearestNeighbors(radius=radius, metric=metric, p=p, metric_params=metric_params, n_jobs=n_jobs)
  knn.fit(X)
  query = _query_include_self(knn._fit_X, include_self, mode)
  return knn.radius_neighbors_graph(query, radius, mode, distance_func=cdist)
