"""Adapted from
sphinx.transforms.post_transforms.ReferencesResolver.resolve_anyref

If 'py' is one of the domains and `py:class` is defined,
the Python domain will be processed before the 'std' domain.
"""
from contextlib import suppress

from docutils import nodes
from sphinx.transforms.post_transforms import ReferencesResolver


class CustomReferencesResolver(ReferencesResolver):
    def resolve_anyref(self, refdoc, node, contnode):
        """Resolve reference generated by the "any" role."""
        stddomain = self.env.get_domain('std')
        target = node['reftarget']

        # first, try resolving as :doc:
        doc_ref = stddomain.resolve_xref(self.env, refdoc, self.app.builder,
                                         'doc', target, node, contnode)
        if doc_ref:
            return self.create_node(('doc', doc_ref))

        # process 'py' domain first for python classes
        if "py:class" in node:
            with suppress(KeyError):
                py_domain = self.env.domains['py']
                py_ref = py_domain.resolve_any_xref(
                    self.env, refdoc, self.app.builder, target, node, contnode)
                if py_ref:
                    return self.create_node(py_ref[0])

        # next, do the standard domain (makes this a priority)
        std_ref = stddomain.resolve_any_xref(
            self.env, refdoc, self.app.builder, target, node, contnode)
        if std_ref:
            return self.create_node(std_ref[0])

        for domain in self.env.domains.values():
            try:
                ref = domain.resolve_any_xref(
                    self.env, refdoc, self.app.builder, target, node, contnode)
                if ref:
                    return self.create_node(ref[0])
            except NotImplementedError:
                # the domain doesn't yet support the new interface
                # we have to manually collect possible references (SLOW)
                for role in domain.roles:
                    res = domain.resolve_xref(self.env, refdoc,
                                              self.app.builder, role, target,
                                              node, contnode)
                    if res and isinstance(res[0], nodes.Element):
                        result = ('%s:%s' % (domain.name, role), res)
                        return self.create_node(result)
        # no results
        return None

    def create_node(self, result):
        res_role, newnode = result
        # Override "any" class with the actual role type to get the styling
        # approximately correct.
        res_domain = res_role.split(':')[0]
        if (len(newnode) > 0 and isinstance(newnode[0], nodes.Element)
                and newnode[0].get('classes')):
            newnode[0]['classes'].append(res_domain)
            newnode[0]['classes'].append(res_role.replace(':', '-'))
        return newnode


def setup(app):

    if (hasattr(app.registry, "get_post_transforms")
            and callable(app.registry.get_post_transforms)):
        post_transforms = app.registry.get_post_transforms()
    else:
        # Support sphinx 1.6.*
        post_transforms = app.post_transforms

    for i, transform_class in enumerate(post_transforms):
        if transform_class == ReferencesResolver:
            post_transforms[i] = CustomReferencesResolver
            break
