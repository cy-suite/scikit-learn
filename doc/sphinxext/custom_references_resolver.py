"""Adapted from
sphinx.transforms.post_transforms.ReferencesResolver.resolve_anyref

If 'py' is one of the domains, it will be processed before the 'std' domain.
"""
from contextlib import suppress

from docutils import nodes
from sphinx.transforms.post_transforms import ReferencesResolver


class CustomReferencesResolver(ReferencesResolver):

    def resolve_anyref(self, refdoc, node, contnode):
        """Resolve reference generated by the "any" role."""
        stddomain = self.env.get_domain('std')
        target = node['reftarget']
        results = []  # type: List[Tuple[str, nodes.Element]]
        # first, try resolving as :doc:
        doc_ref = stddomain.resolve_xref(self.env, refdoc, self.app.builder,
                                         'doc', target, node, contnode)
        if doc_ref:
            results.append(('doc', doc_ref))

        # process 'py' domain first
        with suppress(KeyError):
            py_domain = self.env.domains['py']
            results.extend(py_domain.resolve_any_xref(
                self.env, refdoc, self.app.builder, target, node, contnode))

        # next, do the standard domain (makes this a priority)
        results.extend(stddomain.resolve_any_xref(
            self.env, refdoc, self.app.builder, target, node, contnode))
        for domain in self.env.domains.values():
            if domain.name in ['std', 'py']:
                continue  # we did this one already
            try:
                results.extend(
                    domain.resolve_any_xref(self.env, refdoc, self.app.builder,
                                            target, node, contnode))
            except NotImplementedError:
                # the domain doesn't yet support the new interface
                # we have to manually collect possible references (SLOW)
                for role in domain.roles:
                    res = domain.resolve_xref(self.env, refdoc,
                                              self.app.builder, role, target,
                                              node, contnode)
                    if res and isinstance(res[0], nodes.Element):
                        results.append(('%s:%s' % (domain.name, role), res))
        # now, see how many matches we got...
        if not results:
            return None
        res_role, newnode = results[0]
        # Override "any" class with the actual role type to get the styling
        # approximately correct.
        res_domain = res_role.split(':')[0]
        if (len(newnode) > 0 and
                isinstance(newnode[0], nodes.Element) and
                newnode[0].get('classes')):
            newnode[0]['classes'].append(res_domain)
            newnode[0]['classes'].append(res_role.replace(':', '-'))
        return newnode


def setup(app):

    if (hasattr(app.registry, "get_post_transforms")
            and callable(app.registry.get_post_transforms)):
        post_transforms = app.registry.get_post_transforms()
    else:
        # Support sphinx 1.6.*
        post_transforms = app.post_transforms

    for i, transform_class in enumerate(post_transforms):
        if transform_class == ReferencesResolver:
            post_transforms[i] = CustomReferencesResolver
            break
